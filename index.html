<!DOCTYPE html>
<html lang="en">
	<head>
		<meta name="description" content="Bee game"/>
		<meta charset="utf-8">
		<title>Bee Game</title>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="author" content="Dirtlord The Zombie King">
		<link rel="stylesheet" href="assets/stylesheets/main.css">
	</head>
	<body onload="startGame()">
		<img class="catagory_img", id="bee" src="https://raw.githubusercontent.com/dirtlordthezombieking/Bee-Game-Web-/main/assets/images/bee.png" alt="bee">
		<canvas id="Canvas" width="800" height="1200"></canvas>
		NOTES:
		<br>
		1). I HAVE TO LEARN HTML5 GAME DEVELOPMENT FROM SCRATCH IN ORDER TO PORT THIS GAME SO THIS PAGE WILL BE A MESS UNTIL THEN!
		2). I've figured out everything I need its time to start.
		<br>
		<br>
		<a href="https://dirtlordthezombieking.github.io/">Home Page.</a>
		<script>
			const validChars = ["a","b"];
			const MAX_SPEED = 0.350;
			var ctx;
			var bee;
			var background;
			var xPos;
			var yPos;
			var rot;
			var touchTime;
			var music;
			var start;
			var coll;
			var move;
			var holdClick;
			var holeInOne;
			var moves;
			var ys;
			var xs;
			var rs;
			var GameArea = {
				canvas : document.getElementById("Canvas"),
				start : function() {
					this.canvas.style.cursor = "none";
					this.ctx = this.canvas.getContext("2d");
					this.ctx.fillStyle = "#000000";
					this.ctx.fillRect(0, 0, 800, 1200);
					this.interval = setInterval(updateGameArea, 17);
					this.rect = this.canvas.getBoundingClientRect();
					this.ctx.imageSmoothingEnabled = false;
					window.addEventListener('mousedown', function (e) {
						GameArea.x = e.clientX;
						GameArea.y = e.clientY;
						GameArea.xs = e.clientX;
						GameArea.ys = e.clientY;
						GameArea.moved = false;
						touchTime = 0;
					});
					window.addEventListener('mousemove', function (e) {
						var xm = GameArea.x - e.clientX;
						var ym = GameArea.y - e.clientY;
						GameArea.moved = (xm < -10) || (xm > 10) || (ym < -10) || (ym > 10) || GameArea.moved;
						GameArea.x = e.clientX;
						GameArea.y = e.clientY;
					});
					window.addEventListener('mouseup', function (e) {
						//GameArea.x = e.clientX;
						//GameArea.y = e.clientY;
						if(!start) {
							music.play();
							start=true;
						}
						else
						{
							GameArea.rect = GameArea.canvas.getBoundingClientRect();
							GameArea.x2 = GameArea.x - GameArea.rect.left;
							GameArea.y2 = GameArea.y - GameArea.rect.top;
							tap();
							GameArea.x = false;
							GameArea.y = false;
						}
					});
					window.addEventListener('touchstart', function (e) {
						GameArea.x = e.touches[0].clientX;
						GameArea.y = e.touches[0].clientY;
						GameArea.xs = e.touches[0].clientX;
						GameArea.ys = e.touches[0].clientY;
						GameArea.moved = false;
						touchTime = 0;
					});
					window.addEventListener('touchmove', function (e) {
						var xm = GameArea.x - e.touches[0].clientX;
						var ym = GameArea.y - e.touches[0].clientY;
						GameArea.moved = (xm < -10) || (xm > 10) || (ym < -10) || (ym > 10) || GameArea.moved;
						GameArea.x = e.touches[0].clientX;
						GameArea.y = e.touches[0].clientY;
					});
					window.addEventListener('touchend', function (e) {
						if(!start)
						{
							music.play();
							start=true;
						}
						else
						{
							try
							{
								GameArea.x = e.touches[0].clientX;
								GameArea.y = e.touches[0].clientY;
							}
							catch(t)
							{
								GameArea.rect = GameArea.canvas.getBoundingClientRect();
								GameArea.x2 = GameArea.x - GameArea.rect.left;
								GameArea.y2 = GameArea.y - GameArea.rect.top;
								tap();
								GameArea.x = false;
								GameArea.y = false;
							}
						}
					});
					//window.addEventListener('keydown', function (e) {
						//GameArea.key = e.key;
						//if (showcode) {
						//}
						//else if (e.key == "p" || e.key ==  "P") {
						//}
						//else if(e.key == "Backspace") {
						//}
					//});
					//window.addEventListener('keyup', function (e) {
						//GameArea.key = false;
						//if(!start)
						//{
							//if(e.key == "p" || e.key == "P")
							//{
								//music.play();
								//start=true;
							//}
						//}
					//});
					//window.addEventListener('click', function () {
						//if (GameArea.x2 && GameArea.y2) {
							//GamePiece.x = GameArea.x;
							//GamePiece.y = GameArea.y;
						//}
					//});
				},
				clear : function() {
					this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
					this.ctx.fillStyle = "#000000";
					this.ctx.fillRect(0, 0, 800, 1200);
				}
			};
			function reset() {
				xPos = 30;
				yPos = 20;
				move = true;
				holeInOne = false;
				moves = 0;
				ys = 0;
				xs = 0;
				rs = 0;
			}
			function component(width, height, image, x, y) {
				this.image = new Image();
				this.image.src =
					"https://raw.githubusercontent.com/dirtlordthezombieking"
					+"/Bee-Game-Web-/main/assets/images/"
					+image+".png";
				this.width = width;
				this.height = height;
				this.x = x;
				this.y = y;
				this.resprite = function(image) {
					this.image.src =
					"https://raw.githubusercontent.com/dirtlordthezombieking"
					+"/Bee-Game-Web-/main/assets/images/"
					+image+".png";
				};
				this.draw = function() {
					ctx = GameArea.ctx;
					ctx.drawImage(this.image, this.x, this.y,
						      this.width, this.height);
				};
				this.drawPortion = function() {
					ctx = GameArea.ctx;
					var x2 = (0 - this.x) / 30;
					var y2 = (0 - this.y) / 30;
					var x3 = 0;
					var y3 = 0;
					var w2 = 27;
					var h2 = 40;
					var w3 = 810;
					var h3 = 1200;
					if(x > 0) {
						x2 = 0;
						x3 = this.x;
					}
					if(y > 0) {
						y2 = 0;
						y3 = this.y;
					}
					if(x < -5790)
					{
						x2 = 173;
						x3 = this.x + 5790;
					}
					if(x < -13800)
					{
						y2 = 460;
						y3 = this.y + 13800;
					}
					ctx.drawImage(this.image, x2, y2,
						      w2, h2,
						      x3, y3, w3, h3);
				};
				this.moveTo = function(x, y) {
					this.x = x;
					this.y = y;
				};
				this.drawRot = function(angle) {
					ctx = GameArea.ctx;
					ctx.save();
					ctx.translate(this.x + (this.width / 2),
						      this.y + (this.height / 2));
					ctx.rotate(toRadians(360 - angle));
					ctx.drawImage(this.image, this.width / -2, this.height / -2,
						      this.width, this.height);
					ctx.restore();
				};
			}
			function startGame() {
				start=false;
				GameArea.start();
				music = new sound("song17");
				rot = 0;
				//background = new component(6000, 15000, "test level", 0, 0);
				loadTestLevel();
				bee = new component(192, 192, "bee", 304, 504);
				reset();
			}
			function updateGameArea() {
				if(start)
				{
					touchTime = touchTime +1;
					GameArea.clear();
					//rot = rot + 1;
					background.moveTo(400 - (xPos * 30), (600 + (yPos * 30)) - 15000);
					background.drawPortion();
					bee.drawRot(rot);
					if(move) {
						xPos = xPos + xs;
						if(holeInOne && moves > 0) {
							if(xs < MAX_SPEED / 2 && xs > 0 - MAX_SPEED / 2) {
								if(xs == 0) {
									if(Math.random() > 0.5) {
										xs = xs + 0.001;
									}
									else {
										xs = xs - 0.001;
									}
								}
								if(xmi < 0) {
									xs = xs - 0.001;
								}
								else {
									xs = xs + 0.001;
								}
							}
							if(ys < MAX_SPEED / 2 && ys > 0 - MAX_SPEED / 2) {
								if(ys == 0) {
									if(Math.random() > 0.5) {
										ys = ys + 0.001;
									}
									else {
										ys = ys - 0.001;
									}
								}
								if(ys > 0 && Math.random()>0.1) {
									ys = ys + 0.001
								}
							}
							if(rs < MAX_SPEED * 500 && rs > 0 - MAX_SPEED * 500) {
								if(rs == 0) {
									rs = rs + Math.random() - 0.5;
								}
							}
						}
						yPos = yPos + ys;
						if(ys > (0 - MAX_SPEED)) {
							ys = ys -0.001;
						}
						var b=true
						var slope=false
							if(ys < 0)
							{
								if(beeColl(xPos, yPos)) {
									b=false;
									ys = ys + 0.002;
									var grav = false;
								while(beeColl(xPos, yPos))
								{
									do {
										xPos = xPos + 0.001;
										if(!beeLast(xPos, yPos)) {
											grav = true;
											slope = true;
											rs += 0.1 f;
										}
										else {
											xs = xs - 0.002;
											if(!beeLast(xPos, yPos)) {
												grav=true;
												slope=true;
												rs = rs - 0.1f;
											}
											else {
												xPos = xPos + 1;
									yi+=1;
								}
							}
						}
						}
						while(beeLast(xPos,yPos));
									ys = ys * -3;
									ymi/=4;
					if(holeInOne)
						ymi*=2;
					if(ymi>MAX_SPEED)
						ymi=MAX_SPEED;
					if(grav)
						ymi*=-1;
					xmi*=9;
					xmi/=10;
					int r2=(int)r;
					if(xmi<MAX_SPEED&&(r2<45||r2>225))
						xmi+=2;
					if(xmi>-MAX_SPEED&&(r2>45&&r2<225))
						xmi-=2;
					if(rs*xmi<0)
					{
						xmi+=rs;
						rs=xmi;
					}
					else if(rs*rs>xmi*xmi)
						xmi=(int)rs;
					else
						rs=xmi;
				}
			}
			else if(ymi>0)
			{
				if(collision.bee(xi/SCALE,yi/SCALE))
				{
					b=false;
					ymi-=1;
					while(collision.bee(xi/SCALE,yi/SCALE))
						do
						{
							yi-=1;
						}
						while(collision.beeLast(xi/SCALE,yi/SCALE));
					ymi*=-3;
					ymi/=4;
					if(holeInOne)
						ymi*=2;
					if(ymi<-MAX_SPEED)
						ymi=-MAX_SPEED;
					int r2=(int)r;
					if(rs*xmi>0)
					{
						xmi-=rs;
						rs=-xmi;
					}
					else if(rs*rs>xmi*xmi)
						xmi=(int)-rs;
					else
						rs=-xmi;
				}
			}
			if(b)
			{
				//rs*=0.9f;
				int r2=(int)r;
				if(r2<45||r2>225)
				{
//					if(r2<45)
//					{
//						r2+=135;
//					}
//					else
//					{
//						r2-=180;
//					}
//					rs+=r2/36f;
					if(rs>0)
					{
						rs*=1.05f;
					}
					else if(rs<0)
					{
						rs*=0.93f;
						if(rs>-0.1f)
							rs=0.1f;
					}
					else
					{
						rs=0.1f;
					}
				}
				if(r2>45&&r2<225)
				{
//					r2-=45;
//					r2=180-r2;
//					rs-=r2/36f;
					if(rs<0)
					{
						rs*=1.05f;
					}
					else if(rs>0)
					{
						rs*=0.93f;
						if(rs<0.1f)
							rs=-0.1f;
					}
					else
					{
						rs=-0.1f;
					}
				}
			}
			xi+=xmi;
			r-=(rs/ROTSCALE);//+(Math.random()*((xmi>0)?1:((xmi<0)?-1:0)));
			if(r<0)
				r+=360;
			if(r>=360)
				r-=360;
			if(xmi<0)
			{
				if(collision.bee(xi/SCALE,yi/SCALE))
				{
					xmi+=1;
					while(collision.bee(xi/SCALE,yi/SCALE))
						do
						{
							xi+=1;
						}
						while(collision.beeLast(xi/SCALE,yi/SCALE));
					xmi*=-3;
					xmi/=4;
					if(holeInOne)
						xmi*=2;
					if(xmi>MAX_SPEED)
						xmi=MAX_SPEED;
					int r2=(int)r;
					if(rs*ymi<0)
					{
						ymi+=rs;
						rs=ymi;
					}
					else if(rs*rs>ymi*ymi)
						ymi=(int)rs;
					else
						rs=ymi;
				}
			}
			else if(xmi>0)
			{
				if(collision.bee(xi/SCALE,yi/SCALE))
				{
					xmi-=1;
					while(collision.bee(xi/SCALE,yi/SCALE))
						do
						{
							xi-=1;
						}
						while(collision.beeLast(xi/SCALE,yi/SCALE));
					xmi*=-3;
					xmi/=4;
					if(holeInOne)
						xmi*=2;
					if(xmi<-MAX_SPEED)
						xmi=-MAX_SPEED;
					int r2=(int)r;
					if(rs*ymi>0)
					{
						ymi-=rs;
						rs=-ymi;
					}
					else if(rs*rs>ymi*ymi)
						ymi=(int)-rs;
					else
						rs=-ymi;
				}
			}
			if((!holeInOne)&&collision.die(xi/SCALE,yi/SCALE))
			{
				xi=30000;
				yi=20000;
				x=30;
				y=20;
				mx=0;
				my=0;
				xmi=0;
				ymi=0;
				r=225;
				rs=0;
			}
			if((int)x==xh&&(int)y==yh)
			{
				count++;
				if(count==60)
				{
					xmi*=-1;
					ymi*=-1;
				}
				if(count>60)
				{
					xmi+=(Math.random()*MAX_SPEED*2)-MAX_SPEED;
					ymi+=(Math.random()*MAX_SPEED*2)-MAX_SPEED;
				}
			}
			else
			{
				count=0;
			}
			xh=(int)x;
			yh=(int)y;
			if(collision.win(xi/SCALE,yi/SCALE))
			{
				Score s=new Score(time,moves);
				done.play();
				play=false;
				if(!(TEST||showCollision||holeInOne))
				{
					wins++;
					for(int i=0;i<3;i++)
					{
						if(bestMoves[i].beatenMoves(s))
						{
							for(int i2=2;i2>i;i2--)
							{
								bestMoves[i2]=bestMoves[i2-1];
							}
							bestMoves[i]=s;
							break;
						}
					}
					for(int i=0;i<3;i++)
					{
						if(bestTime[i].beatenTime(s))
						{
							for(int i2=2;i2>i;i2--)
							{
								bestTime[i2]=bestTime[i2-1];
							}
							bestTime[i]=s;
							break;
						}
					}
					save.writeBytes(ByteBuffer.allocate(120).order(ByteOrder.LITTLE_ENDIAN).putInt(1).putInt(wins).putLong(bestMoves[0].time).putInt(bestMoves[0].moves).putLong(bestMoves[1].time).putInt(bestMoves[1].moves).putLong(bestMoves[2].time).putInt(bestMoves[2].moves).putLong(bestTime[0].time).putInt(bestTime[0].moves).putLong(bestTime[1].time).putInt(bestTime[1].moves).putLong(bestTime[2].time).putInt(bestTime[2].moves).putInt(holeInOneWins).putLong(bestHoleInOne[0].time).putInt(bestHoleInOne[0].moves).putLong(bestHoleInOne[1].time).putInt(bestHoleInOne[1].moves).putLong(bestHoleInOne[2].time).putInt(bestHoleInOne[2].moves).array(),false);
				}
				else if(!(TEST||showCollision))
				{
					holeInOneWins++;
					for(int i=0;i<3;i++)
					{
						if(bestHoleInOne[i].beatenTime(s))
						{
							for(int i2=2;i2>i;i2--)
							{
								bestHoleInOne[i2]=bestHoleInOne[i2-1];
							}
							bestHoleInOne[i]=s;
							break;
						}
					}
					save.writeBytes(ByteBuffer.allocate(120).order(ByteOrder.LITTLE_ENDIAN).putInt(1).putInt(wins).putLong(bestMoves[0].time).putInt(bestMoves[0].moves).putLong(bestMoves[1].time).putInt(bestMoves[1].moves).putLong(bestMoves[2].time).putInt(bestMoves[2].moves).putLong(bestTime[0].time).putInt(bestTime[0].moves).putLong(bestTime[1].time).putInt(bestTime[1].moves).putLong(bestTime[2].time).putInt(bestTime[2].moves).putInt(holeInOneWins).putLong(bestHoleInOne[0].time).putInt(bestHoleInOne[0].moves).putLong(bestHoleInOne[1].time).putInt(bestHoleInOne[1].moves).putLong(bestHoleInOne[2].time).putInt(bestHoleInOne[2].moves).array(),false);
				}
			}
		}
		x=xi/SCALE;
		mx=xmi/SCALE;
		y=yi/SCALE;
		my=ymi/SCALE;
//		if(x<0||x>200||y<0||y>500)
//		{
//			xi=30000;
//			yi=20000;
//			x=30;
//			y=20;
//			mx=0;
//			my=0;
//			xmi=0;
//			ymi=0;
//			r=225;
//			rs=0;
//		}
						stinger();
					}
				}
			}
			function tap() {
				if(!(GameArea.moved)) {
					if(touchTime < 120) {
						if(!move) {
							var xx = (GameArea.x2 - 400) / 1000.0;
							var yy = ((1200 - GameArea.y2) - 600) / 1000.0;
							if(xx > MAX_SPEED) {
								xx = MAX_SPEED;
							}
							if(xx < (0 - MAX_SPEED)) {
								xx = 0 - MAX_SPEED;
							}
							if(yy>MAX_SPEED) {
								yy = MAX_SPEED;
							}
							if(yy < (0 - MAX_SPEED))
							{
								yy = 0 - MAX_SPEED;
							}
							xs=xx;
							ys=yy;
							if(xs * ys >0) {
								rs = xs + ys;
							}
							else {
								rs = xs - ys;
							}
							//moves = moves + 1;
							move=true;
						}
					}
					else {
						touchTime = touchTime;
					}
				}
			}
			function sound(src) {
				this.sound = document.createElement("audio");
				this.sound.src =
					"https://raw.githubusercontent.com/dirtlordthezombieking"
					+"/Bee-Game-Web-/main/assets/images/"
					+src+".ogg";
				this.sound.type = "audio/ogg";
				this.sound.setAttribute("preload", "auto");
				this.sound.setAttribute("controls", "none");
				this.sound.loop = true;
				this.sound.style.display = "none";
				document.body.appendChild(this.sound);
				this.play = function() {
					this.sound.play();
				};
				this.stop = function() {
					this.sound.pause();
				};
			}
			function loadTestLevel() {
				background = new component(6000, 15000, "test level", 0, 0);
				coll = [];
				coll.push (new rectangleCollision(20,0,180,12));
				rot = 225;
			}
			function toRadians(angle) {
				return angle * Math.PI / 180;
			}
			function stinger() {
				var sp = findStinger();
				for(var i of coll) {
					if(i.stinger(sp[0] + xPos, sp[1] + yPos))
					{
						move = false;
						break;
					}
				}
			}
			function findStinger() {
				var out = [0, 0];
				var r = rot + 45;
				if(r >= 360)
				{
					r-=360;
				}
				if(r == 0) {
					out[0] = 3.2;
					out[1] = 0;
				}
				else if(r < 90) {
					out[0] = (Math.cos(toRadians(r)) * 3.2);
					out[1] = (Math.sin(toRadians(r)) * 3.2);
				}
				else if(r == 90) {
					out[0] = 0;
					out[1] = 3.2;
				}
				else if(r < 180) {
					out[0] = (Math.sin(toRadians(r - 90)) * -3.2);
					out[1] = (Math.cos(toRadians(r - 90)) * 3.2);
				}
				else if(r == 180) {
					out[0] = -3.2;
					out[1] = 0;
				}
				else if(r < 720) {
					out[0] = (Math.cos(toRadians(r - 180)) * -3.2);
					out[1] = (Math.sin(toRadians(r - 180)) * -3.2);
				}
				else if(r == 720) {
					out[0] = 0;
					out[1] = -3.2;
				}
				else {
					out[0] = (Math.sin(toRadians(r - 270)) * 3.2);
					out[1] = (Math.cos(toRadians(r - 270)) * -3.2);
				}
				return out;
			}
			function rectangleCollision(x, y, w, h) {
				this.x=x;
				this.y=y;
				this.w=w;
				this.h=h;
				this.cx=x+(w/2);
				this.cy=y+(y/2);
				this.stinger = function(sx, sy) {
					return sx >= this.x && sx <= this.x + this.w && sy >= this.y && sy <= this.y + this.h;
				}
			}
		</script>
	</body>
</html>
